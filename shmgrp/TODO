Tested so far, seems to work
============================

Randomness has been introduced where possible to try to hit any unknown race
conditions.

Only functionality has been tested. Memory leaks have not yet been examined.

Single Leader
-------------
+ One member, one thread
	+ Join, pause, leave
	+ Join, make region, destroy region, leave
	+ Join, make N regions, destroy N regions, leave

+ Multiple members, one thread each
	+ Join, pause, leave
	+ Join, make region, destroy region, leave
	+ Join, make N regions, destroy N regions, leave

Known, potential issues or configurations not tested
====================================================

Single Leader
-------------
- One member, one thread
	- Join, intermix creating and destroying N regions, leave

- Multiple members, one thread each
	- Join, intermix creating and destroying N regions, leave

- One member, multiple threads (only first thread does join/leave)
	Each thread does the following across separate executions:
	- Make region, destroy region
	- Make N regions, destroy N regions
	- Intermix creating and destroying N regions

There are many other permutations not yet tested, some noted below.

Other notes
-----------

1. Joining and leaving a group by the same member in fast succession has not
been tested (that's why a sleep is introduced). The inotify thread spawns worker
threads to handle each event.  These worker threads merely invoke the caller's
callback routine to complete the initialization (->establish_/destroy_member).
It may be possible for:

	a. the thread which removes the member to be scheduled before the thread
	adding the member

	b. a member to join and leave multiple times without the inotify registering
	all of them (touch/rm/touch/rm/etc) and it may merge events together

There is sufficient locking to allow multiple threads to handle joins and
departures simultaneously, but this is noting that there may be issues when this
happens from the same member too quickly.

One workaround is to simply make sure code doesn't allow this to happen (e.g.
our test code uses sleep).

2. Leaving a group without explicitly closing all regions.

3. Terminating the leader while there are still active members.

4. Creating and destroying multiple regions simultaneously across multiple
threads within a member.

5. There are memory leaks within both the leader and member code. It is
sufficient to merely join, sleep, then leave a group to experience leaks in both
parties.

6. Haven't tested one member joining multiple groups. That also means the leader
hasn't been tested to open more than one group.

7. Haven't tested a processes being both a member AND leader of two or more
disjoint groups.
